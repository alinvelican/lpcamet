line 2:8 token recognition error at: 'ă'
line 2:15 token recognition error at: 'ă'
line 2:25 token recognition error at: 'ă'
line 2:42 token recognition error at: 'â'
line 2:66 token recognition error at: 'ș'
line 3:27 token recognition error at: 'â'
line 3:29 token recognition error at: 'ș'
line 5:16 token recognition error at: 'ă'
line 21:49 token recognition error at: 'ț'
line 21:54 token recognition error at: 'î'
line 21:61 token recognition error at: 'ț'
line 22:40 token recognition error at: 'ș'
line 22:49 token recognition error at: 'ț'
line 22:54 token recognition error at: 'Ș'
line 22:69 token recognition error at: 'î'
line 22:78 token recognition error at: 'ă'
line 23:57 token recognition error at: 'ă'
line 26:67 token recognition error at: 'ă'
line 43:37 token recognition error at: 'ț'
line 43:45 token recognition error at: 'ă'
line 51:26 token recognition error at: 'î'
line 51:39 token recognition error at: 'ș'
line 51:48 token recognition error at: 'î'
line 51:51 token recognition error at: 'ă'
line 51:53 token recognition error at: 'ț'
line 51:72 token recognition error at: 'ț'
line 71:30 token recognition error at: 'ă'
( : PS
* : ARITMETIC
List : ID
nevid : ID
eterogen : ID
, : VIRGULA
cu : ID
elemente : ID
av : ID
nd : ID
tipul : ID
static : ID
Object : ID
i : ID
tipuri : ID
dinamice : ID
amestecate : ID
. : PUNCT
Sf : ID
r : ID
itul : ID
liste : ID
este : ID
semnalat : ID
de : ID
next : ID
= : INEGALITATI
void : ID
. : PUNCT
Adaptare : ID
dup : ID
Alex : ID
Aiken : ID
. : PUNCT
* : ARITMETIC
) : PD
class : CLASS
List : ID
inherits : INHERITS
IO : ID
{ : AS
elem : ID
: : DP
Object : ID
; : PV
next : ID
: : DP
List : ID
; : PV
init : ID
( : PS
e : ID
: : DP
Object : ID
, : VIRGULA
n : ID
: : DP
List : ID
) : PD
: : DP
List : ID
{ : AS
{ : AS
elem : ID
<- : ATRIBUIRE
e : ID
; : PV
next : ID
<- : ATRIBUIRE
n : ID
; : PV
self : ID
; : PV
} : AD
} : AD
; : PV
print : ID
( : PS
) : PD
: : DP
IO : ID
{ : AS
let : LET
str : ID
: : DP
String : ID
<- : ATRIBUIRE
- : ARITMETIC
- : ARITMETIC
case : ID
permite : ID
ramificarea : ID
execu : ID
iei : ID
n : ID
func : ID
ie : ID
de : ID
tipul : ID
- : ARITMETIC
- : ARITMETIC
dinamic : ID
. : PUNCT
abort : ID
( : PS
) : PD
opre : ID
te : ID
execu : ID
ia : ID
. : PUNCT
irul : ID
vid : ID
care : ID
i : ID
urmeaz : ID
- : ARITMETIC
- : ARITMETIC
este : ID
necesar : ID
pentru : ID
verificarea : ID
static : ID
a : ID
tipurilor : ID
. : PUNCT
case : ID
elem : ID
of : ID
s : ID
: : DP
String : ID
= : INEGALITATI
> : INEGALITATI
s : ID
; : PV
n : ID
: : DP
Int : ID
= : INEGALITATI
> : INEGALITATI
new : NEW
A2I : ID
. : PUNCT
i2a : ID
( : PS
n : ID
) : PD
; : PV
- : ARITMETIC
- : ARITMETIC
A2I : ID
este : ID
definit : ID
mai : ID
jos : ID
o : ID
: : DP
Object : ID
= : INEGALITATI
> : INEGALITATI
{ : AS
abort : ID
( : PS
) : PD
; : PV
"" : STRING
; : PV
} : AD
; : PV
esac : ID
in : IN
{ : AS
out_string : ID
( : PS
str : ID
. : PUNCT
concat : ID
( : PS
" " : STRING
) : PD
) : PD
; : PV
if : IF
( : PS
isvoid : FIRSTEVAL
next : ID
) : PD
then : THEN
out_string : ID
( : PS
"\n" : STRING
) : PD
else : ELSE
next : ID
. : PUNCT
print : ID
( : PS
) : PD
fi : FI
; : PV
} : AD
} : AD
; : PV
} : AD
; : PV
class : CLASS
Main : ID
inherits : INHERITS
IO : ID
{ : AS
main : ID
( : PS
) : PD
: : DP
Object : ID
{ : AS
{ : AS
let : LET
x : ID
: : DP
Int : ID
<- : ATRIBUIRE
0 : INT
, : VIRGULA
y : ID
: : DP
String : ID
<- : ATRIBUIRE
"!" : STRING
, : VIRGULA
z : ID
: : DP
Int : ID
<- : ATRIBUIRE
x : ID
+ : ARITMETIC
2 : INT
, : VIRGULA
empty : ID
: : DP
List : ID
, : VIRGULA
- : ARITMETIC
- : ARITMETIC
ini : ID
ializat : ID
implicit : ID
la : ID
void : ID
list : ID
: : DP
List : ID
<- : ATRIBUIRE
new : NEW
List : ID
. : PUNCT
init : ID
( : PS
x : ID
, : VIRGULA
new : NEW
List : ID
. : PUNCT
init : ID
( : PS
y : ID
, : VIRGULA
new : NEW
List : ID
. : PUNCT
init : ID
( : PS
z : ID
, : VIRGULA
empty : ID
) : PD
) : PD
) : PD
in : IN
list : ID
. : PUNCT
print : ID
( : PS
) : PD
; : PV
- : ARITMETIC
- : ARITMETIC
out_string : ID
ntoarce : ID
IO : ID
, : VIRGULA
i : ID
putem : ID
nl : ID
n : ID
ui : ID
mai : ID
multe : ID
opera : ID
ii : ID
. : PUNCT
let : LET
n : ID
: : DP
Int : ID
<- : ATRIBUIRE
out_string : ID
( : PS
"Calculăm factorial pentru: " : STRING
) : PD
. : PUNCT
in_int : ID
( : PS
) : PD
in : IN
{ : AS
out_string : ID
( : PS
"Factorial recursiv: " : STRING
) : PD
. : PUNCT
out_int : ID
( : PS
fact_rec : ID
( : PS
n : ID
) : PD
) : PD
. : PUNCT
out_string : ID
( : PS
"\n" : STRING
) : PD
; : PV
out_string : ID
( : PS
"Factorial iterativ: " : STRING
) : PD
. : PUNCT
out_int : ID
( : PS
fact_iter : ID
( : PS
n : ID
) : PD
) : PD
. : PUNCT
out_string : ID
( : PS
"\n" : STRING
) : PD
; : PV
} : AD
; : PV
} : AD
} : AD
; : PV
- : ARITMETIC
- : ARITMETIC
factorial : ID
implementat : ID
recursiv : ID
fact_rec : ID
( : PS
n : ID
: : DP
Int : ID
) : PD
: : DP
Int : ID
{ : AS
if : IF
n : ID
= : INEGALITATI
0 : INT
then : THEN
1 : INT
else : ELSE
n : ID
* : ARITMETIC
fact_rec : ID
( : PS
n : ID
- : ARITMETIC
1 : INT
) : PD
fi : FI
} : AD
; : PV
- : ARITMETIC
- : ARITMETIC
factorial : ID
implementat : ID
iterativ : ID
fact_iter : ID
( : PS
n : ID
: : DP
Int : ID
) : PD
: : DP
Int : ID
{ : AS
let : LET
res : ID
: : DP
Int : ID
<- : ATRIBUIRE
1 : INT
- : ARITMETIC
- : ARITMETIC
Blocurile : ID
{ : AS
} : AD
sunt : ID
v : ID
zute : ID
ca : ID
expresii : ID
. : PUNCT
Valoarea : ID
ultimei : ID
expresii : ID
- : ARITMETIC
- : ARITMETIC
din : ID
bloc : ID
este : ID
valoarea : ID
blocului : ID
. : PUNCT
in : IN
{ : AS
while : WHILE
( : PS
not : FIRSTEVAL
( : PS
n : ID
= : INEGALITATI
0 : INT
) : PD
) : PD
loop : LOOP
{ : AS
res : ID
<- : ATRIBUIRE
res : ID
* : ARITMETIC
n : ID
; : PV
n : ID
<- : ATRIBUIRE
n : ID
- : ARITMETIC
1 : INT
; : PV
} : AD
pool : POOL
; : PV
res : ID
; : PV
} : AD
} : AD
; : PV
} : AD
; : PV
<EOF> : EOF
"17-big.cl", line 1:1, Syntax error: extraneous input '*' expecting {FIRSTEVAL, 'new', BOOL, ID, INT, '('}
"17-big.cl", line 2:10, Syntax error: mismatched input 'nevid' expecting {')', ARITMETIC, INEGALITATI}
"17-big.cl", line 12:8, Syntax error: extraneous input '{' expecting {'class', FIRSTEVAL, 'new', 'if', BOOL, 'while', 'let', ID, INT, '}', '('}
"17-big.cl", line 17:4, Syntax error: extraneous input '}' expecting ';'
"17-big.cl", line 21:16, Syntax error: no viable alternative at input 'letstr:String<--'
"17-big.cl", line 26:28, Syntax error: mismatched input '=' expecting {';', '<-'}
(program (stat (expresie ( (expresie * List) nevid eterogen , cu elemente av nd tipul static Object i tipuri dinamice amestecate . Sf r itul liste este semnalat de next = void . Adaptare dup Alex Aiken . * ) class List inherits IO { elem : Object)) ; (stat (decvar next : List)) ; (stat (decfunctie (header init ( (decvars (decvar e : Object) , (decvar n : List)) ) : List) (body { { (stat (asigvar elem <- (expresie e))) ; (stat (asigvar next <- (expresie n))) ; (stat (expresie self)) ; }))) } ; (stat (decfunctie (header print ( ) : IO) (body { let str : String <- - - case permite ramificarea execu iei n func ie de tipul - - dinamic . abort ( ) opre te execu ia . irul vid care i urmeaz - - este necesar pentru verificarea static a tipurilor . case elem of s : String = > s))) ; (stat (decvar n : Int)) = > new A2I . i2a ( n ) ; - - A2I este definit mai jos o : Object = > { abort ( ) ; "" ; } ; esac in { out_string ( str . concat ( " " ) ) ; if ( isvoid next ) then out_string ( "\n" ) else next . print ( ) fi ; } } ; } ; class Main inherits IO { main ( ) : Object { { let x : Int <- 0 , y : String <- "!" , z : Int <- x + 2 , empty : List , - - ini ializat implicit la void list : List <- new List . init ( x , new List . init ( y , new List . init ( z , empty ) ) ) in list . print ( ) ; - - out_string ntoarce IO , i putem nl n ui mai multe opera ii . let n : Int <- out_string ( "Calculăm factorial pentru: " ) . in_int ( ) in { out_string ( "Factorial recursiv: " ) . out_int ( fact_rec ( n ) ) . out_string ( "\n" ) ; out_string ( "Factorial iterativ: " ) . out_int ( fact_iter ( n ) ) . out_string ( "\n" ) ; } ; } } ; - - factorial implementat recursiv fact_rec ( n : Int ) : Int { if n = 0 then 1 else n * fact_rec ( n - 1 ) fi } ; - - factorial implementat iterativ fact_iter ( n : Int ) : Int { let res : Int <- 1 - - Blocurile { } sunt v zute ca expresii . Valoarea ultimei expresii - - din bloc este valoarea blocului . in { while ( not ( n = 0 ) ) loop { res <- res * n ; n <- n - 1 ; } pool ; res ; } } ; } ;)
Compilation halted
